pub struct Tokenizer;
use phf::phf_map;

#[derive(Debug, Clone)]
pub struct Token {
    pub tag: Tag,
    pub loc: Loc,
}

#[derive(Debug, Clone, Copy)]
pub struct Loc {
    pub start: usize,
    pub end: usize,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Tag {
    Invalid,
    InvalidPeriodAsterisks,
    Identifier,
    StringLiteral,
    MultilineStringLiteralLine,
    CharLiteral,
    Eof,
    Builtin,
    Bang,
    Pipe,
    PipePipe,
    PipeEqual,
    Equal,
    EqualEqual,
    EqualAngleBrackRight,
    BangEqual,
    LParen,
    RParen,
    Semicolon,
    Percent,
    PercentEqual,
    LBrace,
    RBrace,
    LBrack,
    RBrack,
    Period,
    PeriodAsterisk,
    Ellipsis2,
    Ellipsis3,
    Caret,
    CaretEqual,
    Plus,
    PlusPlus,
    PlusEqual,
    PlusPercent,
    PlusPercentEqual,
    PlusPipe,
    PlusPipeEqual,
    Minus,
    MinusEqual,
    MinusPercent,
    MinusPercentEqual,
    MinusPipe,
    MinusPipeEqual,
    Asterisk,
    AsteriskEqual,
    AsteriskAsterisk,
    AsteriskPercent,
    AsteriskPercentEqual,
    AsteriskPipe,
    AsteriskPipeEqual,
    Arrow,
    Colon,
    Slash,
    SlashEqual,
    Comma,
    Ampersand,
    AmpersandEqual,
    QuestionMark,
    AngleBrackLeft,
    AngleBrackLeftEqual,
    AngleBrackAngleBrackLeft,
    AngleBrackAngleBrackLeftEqual,
    AngleBrackAngleBrackLeftPipe,
    AngleBrackAngleBrackLeftPipeEqual,
    AngleBrackRight,
    AngleBrackRightEqual,
    AngleBrackAngleBrackRight,
    AngleBrackAngleBrackRightEqual,
    Tilde,
    NumberLiteral,
    DocComment,
    ContainerDocComment,
    KWAddrspace,
    KWAlign,
    KWAllowzero,
    KWAnd,
    KWAnyframe,
    KWAnytype,
    KWAsm,
    KWAsync,
    KWAwait,
    KWBreak,
    KWCallconv,
    KWCatch,
    KWComptime,
    KWConst,
    KWContinue,
    KWDefer,
    KWElse,
    KWEnum,
    KWErrdefer,
    KWError,
    KWExport,
    KWExtern,
    KWFn,
    KWFor,
    KWIf,
    KWInline,
    KWNoalias,
    KWNoinline,
    KWNosuspend,
    KWOpaque,
    KWOr,
    KWOrelse,
    KWPacked,
    KWPub,
    KWResume,
    KWReturn,
    KWLinksection,
    KWStruct,
    KWSuspend,
    KWSwitch,
    KWTest,
    KWThreadlocal,
    KWTry,
    KWUnion,
    KWUnreachable,
    KWUsingnamespace,
    KWVar,
    KWVolatile,
    KWWhile,
}

static TAGS: phf::Map<&'static str, Tag> = phf_map! {
    "addrspace" => Tag::KWAddrspace,
    "align" => Tag::KWAlign,
    "allowzero" => Tag::KWAllowzero,
    "and" => Tag::KWAnd,
    "anyframe" => Tag::KWAnyframe,
    "anytype" => Tag::KWAnytype,
    "asm" => Tag::KWAsm,
    "async" => Tag::KWAsync,
    "await" => Tag::KWAwait,
    "break" => Tag::KWBreak,
    "callconv" => Tag::KWCallconv,
    "catch" => Tag::KWCatch,
    "comptime" => Tag::KWComptime,
    "const" => Tag::KWConst,
    "continue" => Tag::KWContinue,
    "defer" => Tag::KWDefer,
    "else" => Tag::KWElse,
    "enum" => Tag::KWEnum,
    "errdefer" => Tag::KWErrdefer,
    "error" => Tag::KWError,
    "export" => Tag::KWExport,
    "extern" => Tag::KWExtern,
    "fn" => Tag::KWFn,
    "for" => Tag::KWFor,
    "if" => Tag::KWIf,
    "inline" => Tag::KWInline,
    "noalias" => Tag::KWNoalias,
    "noinline" => Tag::KWNoinline,
    "nosuspend" => Tag::KWNosuspend,
    "opaque" => Tag::KWOpaque,
    "or" => Tag::KWOr,
    "orelse" => Tag::KWOrelse,
    "packed" => Tag::KWPacked,
    "pub" => Tag::KWPub,
    "resume" => Tag::KWResume,
    "return" => Tag::KWReturn,
    "linksection" => Tag::KWLinksection,
    "struct" => Tag::KWStruct,
    "suspend" => Tag::KWSuspend,
    "switch" => Tag::KWSwitch,
    "test" => Tag::KWTest,
    "threadlocal" => Tag::KWThreadlocal,
    "try" => Tag::KWTry,
    "union" => Tag::KWUnion,
    "unreachable" => Tag::KWUnreachable,
    "usingnamespace" => Tag::KWUsingnamespace,
    "var" => Tag::KWVar,
    "volatile" => Tag::KWVolatile,
    "while" => Tag::KWWhile,


};

pub fn parse_keyword(tag: &[u8]) -> Option<Tag> {
    if let Ok(as_str) = std::str::from_utf8(tag) {
        TAGS.get(as_str).cloned()
    } else {
        None
    }
}

impl Tag {
    pub fn lexeme(&self) -> Option<&'static str> {
        match self {
            Tag::Invalid
            | Tag::Identifier
            | Tag::StringLiteral
            | Tag::MultilineStringLiteralLine
            | Tag::CharLiteral
            | Tag::Eof
            | Tag::Builtin
            | Tag::NumberLiteral
            | Tag::DocComment
            | Tag::ContainerDocComment => None,

            Tag::InvalidPeriodAsterisks => Some(".**"),
            Tag::Bang => Some("!"),
            Tag::Pipe => Some("|"),
            Tag::PipePipe => Some("||"),
            Tag::PipeEqual => Some("|="),
            Tag::Equal => Some("="),
            Tag::EqualEqual => Some("=="),
            Tag::EqualAngleBrackRight => Some("=>"),
            Tag::BangEqual => Some("!="),
            Tag::LParen => Some("("),
            Tag::RParen => Some(")"),
            Tag::Semicolon => Some(";"),
            Tag::Percent => Some("%"),
            Tag::PercentEqual => Some("%="),
            Tag::LBrace => Some("{"),
            Tag::RBrace => Some("}"),
            Tag::LBrack => Some("["),
            Tag::RBrack => Some("]"),
            Tag::Period => Some("."),
            Tag::PeriodAsterisk => Some(".*"),
            Tag::Ellipsis2 => Some(".."),
            Tag::Ellipsis3 => Some("..."),
            Tag::Caret => Some("^"),
            Tag::CaretEqual => Some("^="),
            Tag::Plus => Some("+"),
            Tag::PlusPlus => Some("++"),
            Tag::PlusEqual => Some("+="),
            Tag::PlusPercent => Some("+%"),
            Tag::PlusPercentEqual => Some("+%="),
            Tag::PlusPipe => Some("+|"),
            Tag::PlusPipeEqual => Some("+|="),
            Tag::Minus => Some("-"),
            Tag::MinusEqual => Some("-="),
            Tag::MinusPercent => Some("-%"),
            Tag::MinusPercentEqual => Some("-%="),
            Tag::MinusPipe => Some("-|"),
            Tag::MinusPipeEqual => Some("-|="),
            Tag::Asterisk => Some("*"),
            Tag::AsteriskEqual => Some("*="),
            Tag::AsteriskAsterisk => Some("**"),
            Tag::AsteriskPercent => Some("*%"),
            Tag::AsteriskPercentEqual => Some("*%="),
            Tag::AsteriskPipe => Some("*|"),
            Tag::AsteriskPipeEqual => Some("*|="),
            Tag::Arrow => Some("->"),
            Tag::Colon => Some(":"),
            Tag::Slash => Some("/"),
            Tag::SlashEqual => Some("/="),
            Tag::Comma => Some(","),
            Tag::Ampersand => Some("&"),
            Tag::AmpersandEqual => Some("&="),
            Tag::QuestionMark => Some("?"),
            Tag::AngleBrackLeft => Some("<"),
            Tag::AngleBrackLeftEqual => Some("<="),
            Tag::AngleBrackAngleBrackLeft => Some("<<"),
            Tag::AngleBrackAngleBrackLeftEqual => Some("<<="),
            Tag::AngleBrackAngleBrackLeftPipe => Some("<<|"),
            Tag::AngleBrackAngleBrackLeftPipeEqual => Some("<<|="),
            Tag::AngleBrackRight => Some(">"),
            Tag::AngleBrackRightEqual => Some(">="),
            Tag::AngleBrackAngleBrackRight => Some(">>"),
            Tag::AngleBrackAngleBrackRightEqual => Some(">>="),
            Tag::Tilde => Some("~"),
            Tag::KWAddrspace => Some("addrspace"),
            Tag::KWAlign => Some("align"),
            Tag::KWAllowzero => Some("allowzero"),
            Tag::KWAnd => Some("and"),
            Tag::KWAnyframe => Some("anyframe"),
            Tag::KWAnytype => Some("anytype"),
            Tag::KWAsm => Some("asm"),
            Tag::KWAsync => Some("async"),
            Tag::KWAwait => Some("await"),
            Tag::KWBreak => Some("break"),
            Tag::KWCallconv => Some("callconv"),
            Tag::KWCatch => Some("catch"),
            Tag::KWComptime => Some("comptime"),
            Tag::KWConst => Some("const"),
            Tag::KWContinue => Some("continue"),
            Tag::KWDefer => Some("defer"),
            Tag::KWElse => Some("else"),
            Tag::KWEnum => Some("enum"),
            Tag::KWErrdefer => Some("errdefer"),
            Tag::KWError => Some("error"),
            Tag::KWExport => Some("export"),
            Tag::KWExtern => Some("extern"),
            Tag::KWFn => Some("fn"),
            Tag::KWFor => Some("for"),
            Tag::KWIf => Some("if"),
            Tag::KWInline => Some("inline"),
            Tag::KWNoalias => Some("noalias"),
            Tag::KWNoinline => Some("noinline"),
            Tag::KWNosuspend => Some("nosuspend"),
            Tag::KWOpaque => Some("opaque"),
            Tag::KWOr => Some("or"),
            Tag::KWOrelse => Some("orelse"),
            Tag::KWPacked => Some("packed"),
            Tag::KWPub => Some("pub"),
            Tag::KWResume => Some("resume"),
            Tag::KWReturn => Some("return"),
            Tag::KWLinksection => Some("linksection"),
            Tag::KWStruct => Some("struct"),
            Tag::KWSuspend => Some("suspend"),
            Tag::KWSwitch => Some("switch"),
            Tag::KWTest => Some("test"),
            Tag::KWThreadlocal => Some("threadlocal"),
            Tag::KWTry => Some("try"),
            Tag::KWUnion => Some("union"),
            Tag::KWUnreachable => Some("unreachable"),
            Tag::KWUsingnamespace => Some("usingnamespace"),
            Tag::KWVar => Some("var"),
            Tag::KWVolatile => Some("volatile"),
            Tag::KWWhile => Some("while"),
        }
    }

    pub fn symbol(&self) -> &'static str {
        self.lexeme().unwrap_or_else(|| match self {
            Tag::Invalid => "invalid token",
            Tag::Identifier => "an identifier",
            Tag::StringLiteral | Tag::MultilineStringLiteralLine => "a string literal",
            Tag::CharLiteral => "a character literal",
            Tag::Eof => "EOF",
            Tag::Builtin => "a builtin function",
            Tag::NumberLiteral => "a number literal",
            Tag::DocComment | Tag::ContainerDocComment => "a document comment",
            _ => unreachable!(),
        })
    }
}

pub struct TokenStream<'a> {
    buffer: &'a [u8],
    index: usize,
}

impl<'a> TokenStream<'a> {
    pub fn new(buffer: &'a [u8]) -> Self {
        let index = if buffer.starts_with(&[0xEF, 0xBB, 0xBF]) {
            3
        } else {
            0
        };
        Self { buffer, index }
    }

    #[cfg(debug_assertions)]
    pub fn dump(&self, token: &Token) {
        match std::str::from_utf8(&self.buffer[token.loc.start..token.loc.end]) {
            Ok(text) => println!("{:?} \"{}\"", token.tag, text),
            Err(_) => println!("{:?} <invalid utf8>", token.tag),
        }
    }
}
